# Базовый Git

[Отличный курс по git](https://www.youtube.com/playlist?list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb)


[CONVENTIONAL COMMENTS](https://conventionalcomments.org/)

## **3 копии репозитория**
 - `local` - находится на компьютере
 - `remote` - находится на github'е
 - `версия посередине` - находится локально на компе, но запоминает состояние remote-репозитория 



`git fetch` - синхронизирует версию remote-репозитория, которая находится локально (версия посередине) с remote репозитрием (получаем информацию о том, что у нас на remote'е)


## Как сохранить незакомиченные изменения и применить их в любом месте (точнее на HEAD~)

`git stash save` - сохранить изменения в памяти

`git stash apply` - применить сохраненные изменения


## Частые кейсы

### Переименовать ветку локально и удаленно

```perl
git branch -m старое_название новое_название
git push origin :старое_название новое_название
```

### Переименовать последний коммит

```shell
git commit --amend -m "new_message"
```

### Связать локальную ветку и удаленную

```shell
git branch -u origin/remote_branch_name
```

### Удалить файл из индекса репозитория
```shell
git rm --cached <filename> 
``` 

## Термины

- `HEAD` - ветка (точнее коммит), на которой находится указатель в текущий момент 

- `HEAD~` - родитель коммита HEAD (можно добавлять несколько **~** или **HEAD~3** - это три коммита назад) 

- `ORIG_HEAD` - эта ссылка указывает на предыдущий коммит, на котором мы находились, когда применили последние изменения

- `MERGE_HEAD` - это ссылка на коммит, с которого делали merge 


## Остальные кейсы

### Переключиться на другую ветку при незакомиченных изменениях

Переключиться, но удалить все незакомиченные изменения

```shell
git checkout -f branchname
```

Удаляет незакомиченные файлы и архивирует их

```shell
git stash
```

Возвращается изменения

```shell
git stash pop
```

### Вернуть состояние одного файла

Посмотреть состояние файла на момент предыдущего коммита

```shell
git show HEAD~ <filename>
```

Добавить в индекс версию файла на момент указанного коммита

```shell
git checkout <commit-hash> <filename>
```

Удалить файл из индекса (сьросит незакомиченные ранее изменения)

```shell
git reset <filename>
```

### **Слияние веток**
Слить ветку branch с веткой master (указатель master передвигается на указатель ветки branch)
```shell
git merge <branch>
```
Передвигает ветку master на коммит с хэшем commit-hash (передвигается указатель ветки master)
```shell
git branch -f master <commit-hash>
```
Отменить коммит слияния (передвинуть `HEAD` на предыдущий коммит, коммит слияния станет недоступен, а затем будет удален)
```shell
git reset --hard HEAD~
```



файл **.git/ORIG_HEAD** содержит идентификатор коммита ветки, который перед началом работы команды **merge**

### **git reset**

#### Жесткий reset

Позволяет откатить состояние до версии, которая была на момент коммита с указанной версией (можно не указывать хэш коммита)

```shell
git reset --hard HEAD <commit-hash> 
```

#### Мягкий reset

`Позволяет переделать неудачный коммит`

Мягкий reset как бы отменяет команду **git commit**, но при этом оставляет изменения в рабочей директории и в индексе репозитория 

```shell
git reset --soft <commit-hash>
```

#### Смешанный reset

Передвигает ветку на указанный коммит, сбрасывает изменения в индексе репозитория, но не изменяет файлы в рабочей директории (отменяет и **git commit** и **git add**)

```shell
git reset --mixed <commit-hash>
```
**--mixed** можно не указывать, он стоит по умолчанию (также можно передавать имя файла)


### **Сравнение коммитов/веток**

```shell
git diff <commit-1> <commit-2>
```

### **Просморт коммитов:** `git log`

Просмотр комиитов, достижимых из HEAD 
```shell
git log
```

Просморт всех коммитов, в виде графа (в консоли)

```shell
git log --all --graph
```

Просмотр файлов, в которых менялся файл `index.html`:

```shell
git log index.html
``` 

### Копирование коммитов: `cherry-pick`

Копирование коммита с указанным хэшем

```shell
git cherry-pich <commit-hash>
```

- x - добавить информацию о том, откуда скопирован коммит

### Отмена коммитов: `git revert`

Смотрит на изменения, указанные в коммите, и создает коммит с противоположными изменениями
```shell
git revert <commit>
```


### Перебазирование веток: `rebase`

Перебазировать текущую ветку на указанную ветку (в данном случае на `master`)

```shell
git rebase master
```

`git rebase --abort` - отменить **rebase** 

`git rebase --onto <куда> <с какого момента>` - перенести, начиная с какого-то момента

`git rebase --rebase-merges master` - перенести текущую ветку на ветку `master` вместе с коммитами слияния (по умолчанию они пропускаются)

`git reset --hard ORIG_HEAD` - отмена **rebase** (но в сложных ситуация лучше через reflog, потому что ORIG_HEAD может не сохраниться)


### УДАЛЕННЫЙ РЕПОЗИТОРИЙ:

```shell
# связать локальный и удаленный репозитории
git remote add origin <repo_link> 	

# запушить ветку в удаленный репозиторий
git push --set-upstream origin <branch>	

# удалить ветку из удаленного репозитория (если локально удалили)
git push --delete origin <branch>		
```

### Git Rebase в Pycharm:
```shell
# лучше всего сделать squash всех коммитов в один
1) git fetch --all

# staging - откуда rebase
2) git rebase origin/staiging 	
```


### ОТМЕНИТЬ REBASE
```shell
git rebase --abort

# или

git reset --soft HEAD~12 (кол-во коммитов)
```

### СТЯНУТЬ ВЕТКУ ИЗ УДАЛЁННОГО РЕПОЗИТОРИЯ
```shell
git fetch origin
git checkout -b <название ветки> origin/<название ветки>
```


### Стянуть удаленный репозиторий
```shell
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/max31ru12/AuthService.git
git push -u origin main
```


### КОМАНДЫ


1. git merge vetka1 - слить ветку vetka с мастер-веткой
2. git branch -d vetka1 vetka2 - удалить ветки с названиями vetka1 и vetka2
3. git push --delete origin vetka1 vetka2 - удалить эти ветки из удаленного репозитория
4. git rebase master - сместить начало текущей ветки на последний коммит ветки master
   необходимо после этого выполнить git push --force
5. git push --force - принудительно перезаписать удаленную ветку на текущую

				ТЕГИ
6. git tab 1.0.0 - пометить последний коммит тегов версии (обычно используются такие циферные обозначения)
7. git tag (git tag --list) - последняя версия (список версий)
8. git push --tags - запушить тегэ в удаленный репозиторий
9. git tag -d 1.0.1 - удалить тег
10. git push --delete origin 1.0.1 - удалить тег 1.0.1 из удаленного репозитория

	ВРЕМЕННОЕ ХРАНИЛИЩЕ ИЗМЕНЕННЫХ ФАЙЛОВ (git stash)
11. git stash - все изменения выгружены во временное хранилище (коммит, который не попадает в общую историю)
12. git stash list - посмотреть стэш (слева - имена стэшей)
13. git stah push имя-файла - добавить изменения файла в уже существующий стэш на текущей ветке
14. git stash pop имя_стэша - прмиенить изменения из стэша

	СКЛЕИВАНИЕ КОММИТОВ (SQUASH)
15. git merge vetka_name --squash - подтягивает изменения с указанной ветки, но не создает коммит объединения
    чтобы записать все изменения в рамках одного коммита
16. git reset --hard (хэш коммита) - сброс состояния текущего репозитория на последний (казанный) коммит
17. git rebase -i HEAD~3 - объединить 3 последних коммита на текущей ветке
    HEAD - текущее состояние репозитория
    вместо pick нужно указать букву: f
    у первого коммита нужно оставить pick
    Esc -> :wq -> Enter
    Загружаем изменения в удаленную ветку git push --force
18. git cherry-pick 940743d - перенести коммит с таким хэшем на текущую ветку
<<<<<<< Updated upstream
=======


## Всякое

Настройка `core.autocrlf` нужна для того, чтобы в главном репозитории все переводы строк текстовых файлах были одинаковы
>>>>>>> Stashed changes
