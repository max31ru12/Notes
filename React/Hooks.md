## `useRef` hook

Это хук, который используется для вещей, которые не нужно рендерить (не возвращаются компонентом). 

> В отличие от `useState`, `useRef` не вызывает ре-рендер компонента!

### Использование `useRef` с `input`:

```ts
inputRef = useRef<HTMLInputElement | null>(null)


return (
    <input type="text" ref={inputRef}/>
)
```

React обрабатывает задание значения `inputRef.current` в **input**. Аналогичен `componentDidMount` в классовых компонентах.

## `useEffect` hook

`useEffect` выполняется:
- после первого рендера компонента;  
- после обновления компонента;

```js
let variable = "some variable"; 

useEffect(() => {
	console.log(variable)
}, [variable])
```

`[variable]`  - массив зависимостей, перменные в котором вызовут срабатывание **хука** 


## `useCallback` hook

`useCallback` используется для мемоизации функций и предотвращения их создания на каждом рендере компонента.

```js
const memoizedFunction = useCallback(
	() => {...},
	[dependency1, dependency2]
);
```

### Почему использовать?

Если передавать куда-либо анонимную функцию: `() => {...}`, то функция создается заново при каждом рендере, это может привести к ре-рендерам.

#### Когда использовать
- Если функция передается в дочерние компоненты
- Если функция используется только внутри текущего компонента, её пересоздание обычно незначительно сказывается на производительности.

#### Когда не использовать
- Если функция используется только внутри текущего компонента, её пересоздание обычно незначительно сказывается на производительности.


## `useMemo` hook

Позволяет мемоизировать (закэшировать) вычисляемоей функцией значение

#### Использование
```js
const calculation = useMemo(
	() => {
		expensiveCalculation(count)
	}, [count]
)
```



