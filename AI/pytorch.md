

## Тензор


### Создание пустого тензора

```python
import torch

t = torch.Tensor(3, 5, 2)  # Размерность тензора
t = torch.empty(3, 5, 2)  # Рекомендуемый способ создания тензора
```

### Создание тензора с данными

```python
t = torch.tensor([1,2,3], [4,5,6]) # размер 2 x 3

t = torch.tensor([2,2], [3,3], [1,1]) # размер 3 x 2
```

### Тип данных тензора

```python
t = torch.empty(3, 5, 2)

t.dtype # torch.float32 по дефолту
t = torch.empty(3, 5, 2, dtype=torch.int32)
```

![[Pasted image 20250718200522.png]]


#### Нулевой тензор

```python
tz = torch.zeros(
	2, 3, dtype=torch.int32
) # 2 строки 3 столбца
```


#### Единичный тензор

```python
tz = torch.ones(3, 3)

tz = torch.eye(3) # амтрица 3x3 единицы по главной диагонали
```

#### Заполнить тензор конкретным значением

```python
tz = torch.fill((3, 5), 123) # размер 3x5, заполнить числом 123
```


#### Заполнить арифметической прогрессией

```python
tz = torch.arange(7) # от 0 до 7 (не включительно)

tz = torch.arange(2, 5) # от 2 до 5 (правая граница должна быть больше, чем левая)

tz = torch.arange(10, 100, 20) # шаг

tz = torch.arange(1, 0, 0.2) # обратный ход
```

#### Linspace: формирование чисел в диапазоне

```python
torch.linspace(1, 5, 2) 
```

Разбивает диапазон чисел от `1 до 5` на указанной кол-во равных частей (в данном случае на `2` равные части()


#### Генерация случайных чисел в тензорах

Зафиксировать генерируемые рандомные числа:

```python
torch.manual_seed(12) # указываем какое-то число
```

##### rand()

1. Диапазон от 0 до 1
2. Равномерное распределение

```python
tz = torch.rand(2, 3) # размерность 2 на 3
```


##### randn()

1. равномерное распределение
2. Нулевое среднее (мат. ожидание)
3. Дисперсия

##### Метод uniform_()
Заполняет тензор случайными вещественными значениями

```python
tz = torch.Tensor(3, 3)

tz = tz.uniform(0, 1) # Заполнить вещестыенными числами от 0 до 1
```

##### Метод normal_()
Заполняет тензор гауссовскими значениями

```python
tz = torch.Tensor(3, 3)

tz.normal_(0, 1)
```

Указывается среднее значение (мат. ожидание) и стандартное отклонение (дисперсия)

### Методы объекта тензора

- `t.dim()` - кол-во осей
- `t.size()` - кол-во элементов на каждой оси
- `t.shape()` - то же самое, что и **.size**


## Конвертирование в Numpy 


```python
d_np = np.array([[1, 2, 3], [4, 5, 6]])

t = torch.from_numpy(d_np)
a = t.numpy() # обратное преобразование
```

Если изменить значение в исходном массиве, то и в тензоре значение изменится, НО НЕ НАОБОРОТ (списки и тензоры не связаны таким образом)

### Методы для преобразования типов тензоров

![[Pasted image 20250719093120.png]]



## Виды методов (функций) в Pytorch

1) `имя_` - inplace (mutable) методы, изменяющие текущий тензор, не создают нового
2) `имя` - immutable методы, не меняют текущий тензор, формируют новый


## Представления тензоров

В примере ниже тензоры опираются на одни и те же данные. То есть если изменить первый эл-т из 1 тензора, то во втором тензоре этот же элемент изменит свое значение 

```python
tz = torch.Tensor(27) # тензор из 27 эл-в

d = tz.view(3, 9) # тензор из 27 эл-в размером 3 на 9 

r = tz.reshape(3, 3, 3) # второй вариант представления тензора в другом размере
```

- `new_tz = tz.resize_(2, 3)` - создать новое представление
- `tz.ravel()` - вытянуть тензор в вектор
- `tz.permute(1, 0)` - поменять оси местами (оси X, Y, Z). Сделать первую ось старого представления нулевой осью нового, нулевую - первой  
- `tz.mT` - транспонирование

## Добавление/удаление осей тензоров

- `torch.unsqueeze(x, dim)` - добавление новой оси (`x` - куда добавляется ось к какому тензору, `dim` на какую ось добавляется новая) **МОЖНО ИСПОЛЬЗОВАТЬ КАК МЕТОД**
- `torch.squeeze(x, dim)` - удаление оси (откуда, какую ось)

