


## HTML CSS

### Что такое scss-модули

это подход к организации стилей, к className добавляется уникальный хэш 

### Зачем нужны модули?

для инкапсуляции стилей в отдельном файле, стили получаются уникальными

### Что такое CSS специфичность

Это способ, с помощью которого браузеры определяют, какие значения свойств CSS наиболее соответствуют элементу (будут применены)
	
Если специфичность одинаковая, то применяется последнее правило
	
Возрастание специфичности:

1. Селекторы тэгов, например `h1`, и псевдоэлементов
2. Селекторы классов `.example`, селекторы атрибутов `[type="radio"]` и псевдоклассов `:hover`
3. Селекторы идентификаторов `#example`

**Инлайн-стили всегда переопределяют любые правила из внешний файлов стилей**. 
	
`!important` получает наивысший приоритет, со специфичностью ничего общего не имеет, но влияет на нее. Усложняет отладку, нарушая естественный каскад стилей.

Специфичность важна тогда, когда собирается css, так как мы не можем предсказать, как он собирается



### Псевдоэлементы

Позволяет стилизовать определенную часть выбранного элемента 

- `::before`
- `::after`
- `::placeholder`

### Псевдоклассы

Определяет особое состояние выбранного селектора

- `:hover`





## Livecoding задачи

### Функция задержки

Написать функцию `delay`, которая буте принимать миллисекунды, на которые нужно задержать выполнение кода, и значение, которое нужно вернуть после задержки


```js
const delay =( ms, returnValue) => {
	return new Promise((resolve) => {
		setTimeout(() => {
			resolve(returnValue)
		}, ms)
	})
}
```


### Порядок вывода в консоль

Какой будет порядок вывода в консоль? `delay` - функция из прошлой задачи

```js
const values = [1,2,3]

values.forEach(async (value) => {
	const result = await delay(1000, value)
	console.log(result)
})
```


Сначала будет выведено **Done**, а потом будет выведено **не** **1,2,3**, так как у forEach есть особенность: 

> forEach принимает функцию  и применяет к каждому элементу массива. Он не дожидается результата выполнения каждого применения этой функции, а идет дальше. Поэтому мы не можем гарантировать порядок вывода


### Как гарантировать порядок вывода

Переписать просто на обычный цикл, без всяких проблем будет работать

```js
for (let i = 0; i < values.length; i++) {
	console.log(await delay(values[i]))
}

for (value of values) {
	console.log(await delay(values[i]))
}
```


### Что выведет код

```js
const items = [
	{ id: 1, name: "Alice"},
	{ id: 2, name: "Bob"},
	{ id: 1, name: "Alice"},
	{ id: 3, name: "Charlie"},
	{ id: 2, name: "Bob"},
]

const uniqueItems = Array.from(new Set(items))
console.log(uniqueItems)
```

Код выведет все элементы из **items**, так как все объекты имеют уникальные ссылки


### Что будет выведено в консоль


```js
async function b() {
	return 1;
}

async function a() {
	return b();
}

const res = await a()
console.log(res)
```


Вызов `b()` вернет **Promise** от 1. `await a()` зарезолвит этот промис, в консоль выведется единица.


## Вопросы TypeScript

### Утилитарные типы

- Omit
- Pick
- Extract
- ReturnType

и так далее.

### Отличие типов от интерфейсов

1. Способ задания
2. Интерфейсы может отнаследовать а типы можно только *конкатенировать* с помощью **логического ИЛИ**
3. Типы могут делать union с примитивными типами, интерфейсы так не умеют
4. У интерфейсов есть declaration merging:
   > Если объявим интерфейс `I` в одном месте со свойством **a**, а в другом месте интерфейс со свойством **b**, то появится итоговый интерфейс, у которого будут свойства и **a**, и **b**




## React 

### Когда происходит рендер (ререндер) компонента

1. Изменился state компонента
2. Изменились props
3. Перерендерился родитель
4. Изменился context


### React lazy

Используемы для декомпозиции JS-бандла, чтобы при переходе по роуту подгружался дополнительный бандл.


### Suspence

Компонент, который позволяет показывать какой-то fallback, пока не готов к рендеру child. Можно использовать с новый "хуком" **use**. 


### Отличие серверных компонентов от клиентских

- Серверные компоненты приходя на клиент в виде готовой разметки. 
- Они не подразумевают какие-то **обработчики**, какие-то **actions**.
- Из серверных компонентов можно стучаться в БД
- Клиентские компоненты тоже рендерятся на сервере, но приходят с JS-чанками, потом проходит процесс ГИДРАЦИИ, который позволяет привязать нужные события к нужным частям

// Что такое JS-бандл, что такое JS-чанки?


### Паттерн render props

```js
const ParentComponent = () => {  
	return (    
		<ChildComponent      
			render={(text) => <h1>{text}</h1>}    
		/>  
	);
};
			
const ChildComponent = ({ render }) => {  
	const text = "Hello World";  
	return <div>{render(text)}</div>;
};  


// Получаем такой код
<div>  
	<h1>Hello World</h1>
</div>
```